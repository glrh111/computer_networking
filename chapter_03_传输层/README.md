+ 两个实体怎么在一种会丢失数据的传输没接上可靠通信
+ 控制传输层实体的传输速率以避免网络拥塞

## 3.1 概述和传输层服务

逻辑通信 logic communication: 通过逻辑通信，运行不同进程的主机好像直接相连一样；实际上，这些主机可能相隔万里，中间有很多路由器和传输链路。

![传输层提供的逻辑通信](http://o9hjg7h8u.bkt.clouddn.com/%E4%BC%A0%E8%BE%93%E5%B1%82%E9%80%BB%E8%BE%91%E9%80%9A%E4%BF%A1.png)

传输层协议是在end system中实现，而不是在路由器中实现。

### 3.1.1 传输层和网络层的关系

传输层为运行在不同主机的进程之间提供了逻辑通信；网络层提供了主机之间的网络通信。

传输层只工作在end system中，负责将message移动到网络层中。

### 3.1.2 传输层概述

IP的服务模型是尽力而为交付服务best-effort delivery service，但是不做任何确保，
+ 不确保segment的交付
+ 不保证segment的按序交付
+ 不保证segment数据的完整性

所以，IP被称为不可靠服务unreliable service.

UDP和TCP最基本的责任是，将两个end system间IP的交付服务扩展为运行在end system上的两个进程之间的交付服务。
将主机间的交付扩展到进程间的交付，被称为传输层的多路复用transport-layer multiplexing, 与多路分解demultiplexing

进程到进程的数据交付和差错检查是两种最低限度的传输层服务，也是UDP能提供的仅有的两项服务。

TCP提供了几种附加服务
+ 可靠数据传输 reliable data transfer 通过使用流量控制，序号，确认和定时器，TCP确保正确的，按序地将数据从发送进程交付给接收进程
+ 拥塞控制 congestion control 力求为每一条拥塞网络链路的连接平等地共享网络连接带宽。

## 3.2 多路复用和多路分解

+ 多路分解demultiplexing 将传输层segment中的数据交付到正确的socket的工作
+ 多路复用multiplexing 在源主机中从不同socket手机数据块，并为每个数据块封装上首部信息，从而生成segment，然后将segment传递到网络层

多路复用的要求：
+ socket有唯一标识符
+ 每个segment有特殊字段来指示该segment所要交付到的socket：源端口号字段source port number field和目的端口号字段destination port number field

端口号是一个16bit的数，大小在0~65535, 0~1023为周知端口号well known port number.

### 1 无连接的多路复用与多路分解

一个UDPsocket可以由一个二元组全面标识，只要具有相同的目的地址和目的端口号，那么segment将通过相同的目的socket定向到相同的目的进程。

### 2 面向连接的多路复用与多路分解

TCPsocket是由一个四元组标识的，包括源地址，源端口号，目的地址，目的端口号，当segment到达一台主机时，全部4个值被用来将segment定向到对应的socket。
除非TCP segment携带了初始创建连接的请求。

![TCP多路复用与多路分解](http://o9hjg7h8u.bkt.clouddn.com/TCP%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3.png)

### 3 WEB服务器与TCP

## 3.3 无连接传输UDP

选择UDP可能基于一下原因：
+ 关于何时、发送什么数据的应用层控制更加精细：因为TCP有拥塞控制，而且必须等接收方确认才会停止重发。
+ 无需建立连接
+ 无连接状态
+ packet首部开销小:每个TCP segment有20bytes的首部开销；UDP只有8个。

应用例子：
+ RIP路由选择表的更新：每隔5分钟更新一次
+ SNMP
+ DNS
+ NFS 远程文件服务器
+ 流媒体或者因特网电话的某些场合

UDP没有拥塞控制，导致较高的丢包率。

使用UDP可以通过在应用层建立某些机制，来保证数据的可靠传输，而无需受制于拥塞控制。

### 3.3.1 UDP segment 结构

RFC 768

首部一共4个字段，8字节
+ 源端口号，目的端口号：多路分解、复用
+ UDP segment的字节数：首部加数据
+ 校验和 checksum
+ 应用数据

### 3.3.2 UDP checksum

RFC 1071

提供了差错检测功能。检验和用于确定当UDP segment从源到达目的地移动时，其中的byte是否改变（例如，由于链路层噪音干扰或者存储在路由器中时引入问题）。
发送方的UDP对segment中所有16byte的和进行反码运算，求和时遇到的任何溢出都被回卷。得到的结果被放在UDP相关字段中。

目的方接收时，所有的字段加起来应该全为1，如果有0，那么传输过程中出差错了。

UDP为什么要提供差错检测？
+ 不是所有的链路层协议都提供了差错检测，不能靠这个
+ 数据脱离链路层到传输层这个阶段，同样有可能引起差错

虽然UDP提供差错检测，但是它对差错恢复无能为力，它可以选择
+ 丢弃受损的segment
+ 交给应用程序并提出警告


## 3.4 可靠数据传输原理 reliable data transfer

![可靠数据传输](http://o9hjg7h8u.bkt.clouddn.com/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93rdt.png)

### 3.4.1 构造可靠数据传输协议 从158(138)页开始

#### 1. 经完全可靠信道的可靠数据传输 rdt1.0



#### 2. 经具有比特差错信道的可靠数据传输 rdt2.0
 
以日常打电话为例，接听方在听到一句话时，可以
+ 肯定确认 positive acknowledgement
+ 否定确认 negative acknowledgement

在计算机网络环境中，基于这样的重传机制的可靠数据传输协议称为自动重传请求automatic repeat reQuest ARQ
+ 差错检测：时接收方可以检测到何时出现了byte差错
+ 接收方反馈：ACK, NAK, 让发送方知道接收方情况。
+ 重传

但是ACK，NAK packet受损怎么办？
+ 考虑打电话场景，发送方将问：你说啥？但是这个你说啥 受损了怎么办？来回重复无穷尽也
+ 增加足够的检验和byte：使发送方不仅可以检测差错，还可恢复差错。对于会产生差错但不会丢失packet的信道，可以
+ 直接重传。但是会在信道中引入冗余分组dupliate packet, 搞得接收方不知道上次发的ACK，NAK是否被发送方正确收到。
因此它无法事先知道，收到的分组是一次新的，还是重传。

解决这个问题的一个方法是，在数据packet中添加一个新字段，于是，接收方只需要检查序号即可确定收到的packet是否是一次重传。

再次改进版本是，接收方可以通过对同一上一个sequence number发送两次ack，来通知发送方没有收到下一个packet。

#### 3. 经具有比特差错的丢包信道的可靠数据传输 rdt3.0

怎样检测丢包，发生丢包后该做什么？

如果一个发送方，发出去的packet未被收到，或者ack丢失，那么发送方需要等待足够长的时间，以决定重传packet。

如果因为网络阻塞，导致发送方经历很久才收到ack，此时重发的packet称为冗余数据packet duplicate data packet.

基于时间的重传机制，需要倒计时定时器countdown timer, 发送方需要做到：
+ 每次发送一个packet，启动一个定时器
+ 响应定时器中断
+ 终止定时器

至此，我们得到了一个可靠的数据传输协议

### 3.4.2 流水线可靠数据传输协议

rdt3.0 是一个功能正确的协议，但是性能不咋地。核心在与它是一个停等协议。

发送方(或信道)利用率：传输时延（发送方实际忙于将发送比特送进信道的那部分时间）/ 发送时间。

U = (L/R) / (RTT+L/R) 停等协议的u非常低。

![停等协议与流水线协议](http://o9hjg7h8u.bkt.clouddn.com/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE.png)

流水线协议对可靠数据传输协议可带来如下影响：
+ 必须增加序号范围，每个传送中的packet必须有一个唯一的序号
+ 协议的发送和接收两端也必须缓冲多个packet。发送方最少应该缓冲那些已经发送但是没有ack的packet；
接收方或许应该缓存已经正确接受的packet
+ 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的packet。解决流水线差错恢复有两种基本方法
  + 回退N步 Go-Back N
  + 选择重传 Selective Repeat SR

### 3.4.3 回退N步GBN Page167

如果某个ack没有收到，那么发送从该ack之后的所有packet，容易产生较多的冗余packet。

### 3.4.4 选择重传 SR

可靠数据传输机制及其用途的总结
+ 检验和 用于检验在一个传输packet中的比特错误
+ 定时器 用于超时/重传一个packet，可能因为该packet或者它的ack在信道中丢失了。
+ 序号   用于为从发送方流向接收方的数据packet按顺序编号。
+ 确认   接收方用于通知发送方某个packet或一组packet已经被正确接收到。确认ack里边可以包含多个packet编号
+ 否定确认 接收方用于告诉发送方,某个packet未被正确接收，否定接收报文通常携带未被正确接收的packet的序号
+ 窗口、流水线 发送方也许被限制仅发送那些序号落在一个指定范围内的packet。这样就允许发送方一次发送多个packet。
窗口长度可以根据接收方接收和缓存报文的能力、网络中的拥塞程度，或两者情况来进行设置。



## 3.5 面向连接的传输 TCP

TCP依赖于差错检测、重传、累积确认、定时器、用于序号和确认号的首部字段。RFC 793, RFC 1122, RFC 1323, RFC 2018, RFC 2581

### 3.5.1 TCP连接

TCP被称为是面向连接的 connection-oriented , 这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，
这两个进程必须先相互握手，即他们必须先发送某些预备报文段，以建立确保数据传输的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。
 



























